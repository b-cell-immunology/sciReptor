# Name:			lib_flowcyt_sorting_indexed.R
# Verson:		0.1.1  (2014-04-29)
# Author(s):	Christian Busse
# Maintainer:	Christian Busse (busse@mpiib-berlin.mpg.de)
# Licence:		AGPL3
# Provides:		Functions to read index sort location data along with the flow cytometric parameters from FCS files produced by BD's 
#				FACSDiVa software (Versions 7 and 8 should work, but only 8 is tested). The evalulated keywords are not standardized
#				up to FCS3.1, therefore data from non-BD machines/software will most likely not work.
# Requires:		Bioconductor flowCore package
# 
#

library(flowCore)

# Defines the supported versions of FCS files
#
config.fcs.versions.valid            <- c("FCS2.0","FCS3.0","FCS3.1")
config.fcs.versions.supported        <- c("FCS2.0","FCS3.0")
config.fcs.keyword.creator.supported <- c("BD FACSDiva Software Version 8.0")

# Call:			func.read.indexed.FCS(filename)
#
# Parameters:	<filename>:							Complete filename (if necessary including path) of the FCS file
#
# Returns:		A list containing the following elements:
#				- "file"        [string]	The filename of the FCS (Note that this is the current filename, not the one stored in the $FIL keyword)
#				- "fcs.version" [string]	The "FCSx.y" version string of the file
#				- "dimensions"  [vector]	The dimensions of the target plate as stored in "INDEX SORTING DEVICE_DIMENSION". First value is rows, second columns.
#				- "keyword"		[matrix]	The list of keywords.
#				- "data"		[matrix]	The flow cytometric anf location data for all $TOT events in the file ($PAR + 3 columns). Note that "row" and "column"
#											are real coordinates NOT offsets to well A01. "events" are counted from A01 left-to-right, then top-to-bottom.
#
# Description:	This function reads an FCS file containing index sort data and returns a list data structure contain flow cytometric and location data.
#
func.read.indexed.FCS <- function(fcs.file.full, require.sorting.plate.barcode) {

	# Sanity checks 1. There is no flowCore internal function to test for the actual FCS version, therefore this information is retreived
	# via a direct read (thats basically the same thing that isFCSfile() does). Currently (04/2014) flowCore does not support FCS3.1 which
	# contains some changes in keywords, therefore there is a two-stage test plus the check whether flowCore support hass changed.
	#
	if( ! file.exists(fcs.file.full)) {
		stop(paste("File", fcs.file.full, "does not exist. Aborting!"))
	}
	fcs.version <- readChar(fcs.file.full, 6)
	if( ! fcs.version %in% config.fcs.versions.supported) {
		if(fcs.version %in% config.fcs.versions.valid) {
			stop(
				paste(
					"File ", fcs.file.full, " uses currently unsupported ", fcs.version, "! ",
					"Current flowCore support for this version is ", as.character(unname(isFCSfile(fcs.file.full))[1]), "! ",
					"Aborting!",
					sep=""
				)
			)
		} else {
			stop(paste("File", fcs.file.full, "is not a valid FCS file. Aborting!"))
		}
	}

	fcs.data <- read.FCS(fcs.file.full)


	# Sanity checks 2. Files might have been recorded during an index sort without actually containing index sort location data. Until further 
	# information is provided from BD, the testing for the "INDEX SORT DEVICE TYPE" and "INDEX SORT SORTED LOCATION COUNT" seems to be the most 
	# reliable option to sort this out.
	#
	if(is.null(description(fcs.data)$"CREATOR")) {
		warning(paste("File ",fcs.file.full, " does not contain a CREATOR keyword.", sep=""))
	} else {
		 if (! description(fcs.data)$"CREATOR" %in% config.fcs.keyword.creator.supported) {
			warning(paste("File ",fcs.file.full, " was generated by unsupported CREATOR ", description(fcs.data)$"CREATOR", ".", sep=""))
		 }
	}

	if(is.null(description(fcs.data)$"INDEX SORTING SORTED LOCATION COUNT")) {
		if(is.null(description(fcs.data)$"INDEX SORTING DEVICE TYPE")) {
			stop(paste("File ",fcs.file.full, " does not contain index sort data. Aborting!", sep=""))
		} else {
			stop(paste("File ",fcs.file.full, " does contain some index sort data but no location information. Aborting!", sep=""))
		}
	}

	fcs.index.sorting.sorted.location.count <- as.integer(description(fcs.data)$"INDEX SORTING SORTED LOCATION COUNT")

	if(fcs.index.sorting.sorted.location.count != as.integer(description(fcs.data)$"$TOT")) {
		stop(
			paste(
				"File ", fcs.file.full, "has non-identical counts for total (n=", as.integer(description(fcs.data)$"$TOT"),
				") versus sorted events (n=", fcs.index.sorting.sorted.location.count,
				"). Aborting!",
				sep=""
			)
		)
	}


	# Get metainfo on the type and size of the sorting device.
	# CAVE: The device definition in BD FACSDiVa software is transposed (rows x columns) in comparision to the "normal" plate format (columns x rows).
	# However this is only true for the device definition, the index sorting information are in a "<column_offset>,<row_offset>;" format.
	#
	fcs.index.sorting.device.type <- as.integer(description(fcs.data)$"INDEX SORTING DEVICE TYPE")
	fcs.index.sorting.device.dimension <- as.integer(unlist(strsplit(description(fcs.data)$"INDEX SORTING DEVICE_DIMENSION",":")))
	names(fcs.index.sorting.device.dimension) <- c("rows","columns")


	# Parse INDEX SORTING LOCATION data into a single table. The information of order in the metainfo has to be stored since it is the only way
	# to associate the location data with the cytometry data.
	# The transposition of the lapply output and the "byrow" of the following matrix command are necessary since the number of locations given
	# in one line of the INDEX SORTING LOCATIONS metainfo varies. Further note that the values in the metainfo are offsets to well A01, therefore
	# all numbers are incremented by one to obtain the row / column number.
	#
	fcs.index.sorting.wells <- matrix(
		unlist(
			lapply(
				grep("INDEX SORTING LOCATIONS", names(description(fcs.data)),value=TRUE), 
				function(fcs.index.sorting.location.current) {
					temp.sorting.locations <- matrix(
						as.integer(
							unlist(
								strsplit(
									unlist(
										strsplit(
											description(fcs.data)[[fcs.index.sorting.location.current]],
											";"
										)
									),
									","
								)
							)
						) + 1,
						ncol=2,
						byrow=TRUE,
						dimnames=list(NULL,c("row", "column"))
					)
					temp.sorting.locations <- cbind(
						temp.sorting.locations,
						matrix(
							c(
								(temp.sorting.locations[,"row"]-1) * fcs.index.sorting.device.dimension["columns"] + temp.sorting.locations[,"column"],
								rep(as.integer(sub("^INDEX\ SORTING\ LOCATIONS_","",fcs.index.sorting.location.current)), dim(temp.sorting.locations)[1]),
								seq(1,dim(temp.sorting.locations)[1])
							),
							ncol=3,
							dimnames=list(NULL,c("event","line","element"))
						)
					)
					t(temp.sorting.locations)
				}
			)
		),
		ncol=5,
		byrow=TRUE,
		dimnames=list(NULL,c("row", "column","event","line","element"))
	)

	# Sanity checks 3. Test whether:
	# - there are any line+element combinations that are non-unique
	# - index sorting locations are outside of the dimensions of the device
	# - there are any column+row combinations that are non-unique
	# - there are any event numbers that are non-unique
	#
	if (any(duplicated(paste(fcs.index.sorting.wells[,"line"],fcs.index.sorting.wells[,"element"],sep="_")))) {
		stop(
			paste(
				"Collision in lines and elements parsed from the INDEX SORTING LOCATIONS of file ", fcs.file.full, ". Aborting!",
				sep=""
			)
		)
	}

	if ( 
		max(fcs.index.sorting.wells[,"row"]) > fcs.index.sorting.device.dimension["rows"] || min(fcs.index.sorting.wells[,"row"]) < 1 ||
		max(fcs.index.sorting.wells[,"column"]) > fcs.index.sorting.device.dimension["columns"] || min(fcs.index.sorting.wells[,"column"]) < 1
	) {
		stop(
			paste(
				"Index sorting locations (",
				min(fcs.index.sorting.wells[,"column"]), ">", max(fcs.index.sorting.wells[,"column"]),
				":",
				min(fcs.index.sorting.wells[,"row"]), ">", max(fcs.index.sorting.wells[,"row"]),
				") in file ",
				fcs.file.full,
				"are outside of device dimensions (", fcs.index.sorting.device.dimension["columns"], ":", fcs.index.sorting.device.dimension["rows"],
				"). Aborting!",
				sep=""
			)
		)
	}

	if (any(duplicated(paste(fcs.index.sorting.wells[,"row"],fcs.index.sorting.wells[,"column"],sep="_")))) {
		stop(
			paste(
				"Collision in columns and rows parsed from the INDEX SORTING LOCATIONS of file ", fcs.file.full, ". Aborting!",
				sep=""
			)
		)
	}

	if ( any(duplicated(fcs.index.sorting.wells[,"event"]))) {
		stop(
			paste(
				"Collision in event numbers calculated from the INDEX SORTING LOCATIONS of file ", fcs.file.full, ". Aborting!",
				sep=""
			)
		)
	}

	# Combine cytometry and location data. This requires that the location data is ordered according to the sequence in which the cells were sorted.
	#
	fcs.index.sorting.wells <- fcs.index.sorting.wells[order(fcs.index.sorting.wells[,"line"],fcs.index.sorting.wells[,"element"]),]
	
	if(is.null(description(fcs.data)$SPILL)) {
		warning(paste("File ",fcs.file.full, " lacks $SPILL compensation matrix. Skipping compensation!", sep=""))
		fcs.data.export <- exprs(fcs.data)
	} else {
		fcs.data.export <- exprs(compensate(fcs.data, description(fcs.data)$SPILL))
	}
	fcs.data.export <- cbind(
		fcs.data.export,
		fcs.index.sorting.wells[,c("event","row","column")]
	)

	fcs.data.export <- fcs.data.export[order(fcs.data.export[,"event"]),]


	return(
		list(
			file=fcs.file.full,
			fcs.version=fcs.version,
			dimensions=fcs.index.sorting.device.dimension,
			description=description(fcs.data),
			data=fcs.data.export
		)
	)
}
